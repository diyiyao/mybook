{"./":{"url":"./","title":"Introduction","keywords":"","body":"README 说明详见 https://github.com/riskers/blog/issues/48 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"intro/":{"url":"intro/","title":"简介","keywords":"","body":"简介 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"tools/directory.html":{"url":"tools/directory.html","title":"工具类","keywords":"","body":"工具类 GitBook Markdown By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"tools/GitBook.html":{"url":"tools/GitBook.html","title":"GitBook","keywords":"","body":"GitBook 简介 这是 gitbook 项目主页上对 gitbook 的定义。 gitbook 首先是一个软件，正如上面定义的那样，它使用 Git 和 Markdown 来编排书本，如果用户没有听过 Git 和 Markdown，那么 gitbook 可能不适合你！ 本书也是使用 gitbook 生成，所以在看到这里的时候，你应该对 gitbook 的魔力有了初步印象！ 安装 gitbook 的安装非常简单，详细指南可以参考 gitbook 文档。 这里的安装只需要一步就能完成！ $ npm install gitbook-cli -g 需要注意的是：用户首先需要安装 nodejs，以便能够使用 npm 来安装 gitbook。 基本使用 gitbook 的基本用法非常简单，基本上就只有两步： 使用gitbook init初始化书籍目录 使用gitbook serve编译书籍 可能会出现的问题： ➜ ebook git:(master) ✗ gitbook pdf . /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 这是因为node版本过高导致。 修复方式: 打开/usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js 下面是出问题的函数: function statFix (orig) { if (!orig) return orig // Older versions of Node erroneously returned signed integers for // uid + gid. return function (target, cb) { return orig.call(fs, target, function (er, stats) { if (!stats) return cb.apply(this, arguments) if (stats.uid 这似乎修复了旧版本Node.js中的一些问题。 在同一文件的第62-64行中被使用: fs.stat = statFix(fs.stat) fs.fstat = statFix(fs.fstat) fs.lstat = statFix(fs.lstat) 修改后 // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) 下面将结合一个非常简单的实例，来介绍 gitbook 的基本用法。 gitbook init 首先，创建如下目录结构： $ tree book/ book/ ├── README.md └── SUMMARY.md 0 directories, 2 files README.md 和 SUMMARY.md 是两个必须文件，README.md 是对书籍的简单介绍： $ cat book/README.md # README This is a book powered by [GitBook](https://github.com/GitbookIO/gitbook). SUMMARY.md 是书籍的目录结构。内容如下： $ cat book/SUMMARY.md # SUMMARY * [Chapter1](chapter1/README.md) * [Section1.1](chapter1/section1.1.md) * [Section1.2](chapter1/section1.2.md) * [Chapter2](chapter2/README.md) 创建了这两个文件后，使用 gitbook init，它会为我们创建 SUMMARY.md 中的目录结构。 $ cd book $ gitbook init $ tree . ├── README.md ├── SUMMARY.md ├── chapter1 │ ├── README.md │ ├── section1.1.md │ └── section1.2.md └── chapter2 └── README.md 2 directories, 6 files gitbook serve 书籍目录结构创建完成以后，就可以使用 gitbook serve 来编译和预览书籍了： $ gitbook serve Press CTRL+C to quit ... Live reload server started on port: 35729 Starting build ... Successfully built! Starting server ... Serving book on http://localhost:4000 gitbook serve 命令实际上会首先调用 gitbook build 编译书籍，完成以后会打开一个 web 服务器，监听在本地的 4000 端口。 现在，可以用浏览器打开 http://127.0.0.1:4000 查看书籍的效果，如下图： 配置 所有的配置都以JSON格式存储在名为 book.json 的文件中。 你可以粘贴你的book.json去 jsonlint.com 验证JSON语法。 gitbook在编译书籍的时候会读取书籍源码顶层目录中的 book.js 或者 book.json，这里以 book.json 为例，参考 gitbook 文档 可以知道，book.json 支持如下配置： { \"author\": \"Chengwei Yang \", \"description\": \"This is a sample book created by gitbook\", \"extension\": null, \"generator\": \"site\", \"isbn\": null, \"links\": { \"sharing\": { \"all\": null, \"facebook\": null, \"google\": null, \"twitter\": null, \"weibo\": null }, \"sidebar\": { \"Chengwei's Blog\": \"http://www.chengweiyang.cn\" } }, \"output\": null, \"pdf\": { \"fontSize\": 12, \"footerTemplate\": null, \"headerTemplate\": null, \"margin\": { \"bottom\": 36, \"left\": 62, \"right\": 62, \"top\": 36 }, \"pageNumbers\": false, \"paperSize\": \"a4\" }, \"plugins\": [], \"title\": \"Sample GitBook\", \"variables\": {} } 需要注意的是：GitBook.com 上的书籍标题经试验不能通过配置 book.json 的方式修改 title，需要在书籍的属性页面中的 'Settings' 中进行修改！ 插件 插件是扩展 GitBook 功能（电子书和网站）最好的方式。现在插件可以做很多事：支持数学公式的显示，使用 Google Analytic 追踪访问，... 如何查找插件？ 可以在 plugins.gitbook.com 上很轻松的查找插件。 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"tools/Markdown.html":{"url":"tools/Markdown.html","title":"Markdown","keywords":"","body":"Markdown By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"works/directory.html":{"url":"works/directory.html","title":"工作","keywords":"","body":"目录 付款单模型 常用命令 curl的用法指南 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"works/付款单模型.html":{"url":"works/付款单模型.html","title":"付款单模型","keywords":"","body":"付款单模型 业务背景 现有合同预付、入库预付、应付未付、费用预付、对公费用5种待付款单类型。 每个付款单会有不同使用场景，且每个类型都有自身的业务规则。 存在问题 随着业务的深入，业务规则和校验规则越来越大，导致付款单模型越来越膨胀，每个付款单类型的边界和职责越来越不清晰，导致后续人员可读性和维修性成本增加。 我们开发风格也接近以事务脚本式风格，导致可维护性差、可扩展性差、可测试性差。 一个待付款单会存在多次付款的情况，因金额或合同问题，可能需要分批分时间进行付款操作。导致待付款单和付款单的关系 存在多对多 业务理解困难，出现我也不知道的问题。 不同待付款单类型，对应的唯一KEY(合同号、订单号)不同，导致校验规则不统一。 缺少开发步骤指导、每一层的module、package的职责不明确，后续接力困难 解决方案 引入DDD方案，抽取付款单模型、抽取待付款单模型 解方程步骤: 先解DO -> Domain（Entity） 这一层关系 付款单模型 待付款单模型 Repository实现 1.所有的 Entity/Aggregate 会被转化为 DO，然后根据业务 场景，调用相应的 DAO 方法进行操作，事后如果需要则把 DO 转换回 Entity。 2.当涉及到多 Entity 的 Aggregate Root时，需要能识别到底哪些 Entity 有变更，并且只针对那些变更过的 Entity 做操作，就需要加上变更追踪的能力。 业界有两个主流的变更追踪方案: 基于 Snapshot 的方案:当数据从 DB 里取出来后，在内存中保存一份 snapshot，然后 在数据写入时和 snapshot 比较。常见的实现如 Hibernate。 基于Proxy的方案:当数据从DB里取出来后，通过weaving的方式将所有setter都增 加一个切面来判断 setter 是否被调用以及值是否变更，如果变更则标记为 Dirty。在保 存时根据 Dirty 判断是否需要更新。常见的实现如 Entity Framework。 Snapshot 方案的好处是比较简单，成本在于每次保存时全量 Diff 的操作(一般用 Reflection)，以及保存 Snapshot 的内存消耗。 Proxy 方案的好处是性能很高，几乎没有增加的成本，但是坏处是实现起来比较困难，且当 有嵌套关系存在时不容易发现嵌套对象的变化(比如子 List 的增加和删除等)，有可能导致 bug。 由于 Proxy 方案的复杂度，业界主流(包括 EF Core)都在使用 Snapshot 方案。这里面还 有另一个好处就是通过 Diff 可以发现哪些字段有变更，然后只更新变更过的字段，再一次 降低 UPDATE 的成本。 Entity实现 使用实体模型，模型里面实现业务代码和校验。 注:实体对象 不依赖任何外部服务和框架，而是纯内存中的数据和操作。这些对象我们打包为 Domain Layer(领域层)。领域层没有任何外部依赖关系。 创建Entity方式 使用 Factory 模式来降低调用方复杂度,同时创建Entity对象 constructor 参数要包含所有必要属性，或者在 constructor 里有合理的默认值。 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"works/常用命令/directory.html":{"url":"works/常用命令/directory.html","title":"常用命令","keywords":"","body":"目录 curl的用法指南 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"works/常用命令/curl的用法指南.html":{"url":"works/常用命令/curl的用法指南.html","title":"curl的用法指南","keywords":"","body":"curl的用法指南 curl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。 它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。 不带有任何参数时，curl 就是发出 GET 请求。 $ curl https://www.example.com -A -具体场景 调用本地服务接口 curl -b 'SSO_USER_TOKEN=ss_b9EpJdin0QufvJ_BLh17zctlFIsLtw_wSER0yhkypwjzRZ9DXG6QvtBdaIKSUzeF2hYyoRS4AHREeRAqEMmRd3exrpF-QkSX9aBaQUfzLyGvXWgF61ds-wJAPzk8t0kb0TPbDvXTtrI1NJI7BMgL9sJq15wQ' -H \"Content-Type: application/json\" -X POST -d \"{\\\"bindRequestDTOS\\\":[{\\\"amount\\\":0.1,\\\"bindTime\\\":1615185891561,\\\"bindUser\\\":\\\"system\\\",\\\"bindUserNick\\\":\\\"system\\\",\\\"bizCode\\\":\\\"LM20210308409509\\\",\\\"companyCode\\\":\\\"2000\\\",\\\"currency\\\":\\\"CNY\\\",\\\"customerCode\\\":\\\"TYKH201910213GPk\\\",\\\"iotWalletAccount\\\":\\\"112eb05002402000\\\",\\\"payerCustomerCode\\\":\\\"0001000055\\\",\\\"sapOrderCode\\\":\\\"1130027021\\\",\\\"transactionNumber\\\":\\\"SH20210305AE2PEIUCW740daily\\\"}],\\\"reqId\\\":\\\"7\\\"}\" http://localhost:9436/capitalBind/v1/walletBalanceBind By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"blogs/directory.html":{"url":"blogs/directory.html","title":"博客","keywords":"","body":"目录 DDD 微服务代码模型 资金认领的实践 git git发布流程 spring @Resource和@Autowired的区别 @Resource、@Autowired、@Value的循环依赖 Spring源码之@Component注解解析 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"blogs/DDD/directory.html":{"url":"blogs/DDD/directory.html","title":"DDD","keywords":"","body":"目录 微服务代码模型 资金认领的实践 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"blogs/DDD/微服务代码模型.html":{"url":"blogs/DDD/微服务代码模型.html","title":"微服务代码模型","keywords":"","body":"微服务代码模型 微服务一级目录结构 Interfaces(用户接口层): 它主要存放用户接口层与前端交互、展现数据相关的代码。前 端应用通过这一层的接口，向应用服务获取展现所需的数据。这一层主要用来处理用户发送 的 Restful 请求，解析用户输入的配置文件，并将数据传递给 Application 层。数据的组 装、数据传输格式以及 Facade 接口等代码都会放在这一层目录里。 Application(应用层): 它主要存放应用层服务组合和编排相关的代码。应用服务向下基 于微服务内的领域服务或外部微服务的应用服务完成服务的编排和组合，向上为用户接口层 提供各种应用数据展现支持服务。应用服务和事件等代码会放在这一层目录里。 Domain(领域层): 它主要存放领域层核心业务逻辑相关的代码。领域层可以包含多个聚 合代码包，它们共同实现领域模型的核心业务逻辑。聚合以及聚合内的实体、方法、领域服 务和事件等代码会放在这一层目录里。 Infrastructure(基础层): 它主要存放基础资源服务相关的代码，为其它各层提供的通用 技术能力、三方软件包、数据库服务、配置和基础资源服务的代码都会放在这一层目录里。 各层目录结构 1. 用户接口层 Interfaces 的代码目录结构有:assembler、dto 和 façade 三类。 Assembler: 实现 DTO 与领域对象之间的相互转换和数据交换。一般来说 Assembler 与 DTO 总是一同出现。 Dto: 它是数据传输的载体，内部不存在任何业务逻辑，我们可以通过 DTO 把内部的领域 对象与外界隔离。 Facade: 提供较粗粒度的调用接口，将用户请求委派给一个或多个应用服务进行处理。 2. 应用层 Application 的代码目录结构有:event 和 service。 Event(事件): 这层目录主要存放事件相关的代码。它包括两个子目录:publish 和 subscribe。前者主要存放事件发布相关代码，后者主要存放事件订阅相关代码(事件处理 相关的核心业务逻辑在领域层实现)。 这里提示一下:虽然应用层和领域层都可以进行事件的发布和处理，但为了实现事件的统一 管理，我建议你将微服务内所有事件的发布和订阅的处理都统一放到应用层，事件相关的核 心业务逻辑实现放在领域层。通过应用层调用领域层服务，来实现完整的事件发布和订阅处 理流程。 Service(应用服务): 这层的服务是应用服务。应用服务会对多个领域服务或外部应用服 务进行封装、编排和组合，对外提供粗粒度的服务。应用服务主要实现服务组合和编排，是 一段独立的业务逻辑。你可以将所有应用服务放在一个应用服务类里，也可以把一个应用服 务设计为一个应用服务类，以防应用服务类代码量过大。 3.领域层 Domain 是由一个或多个聚合包构成，共同实现领域模型的核心业务逻辑。聚合内的代码 模型是标准和统一的，包括:entity、event、repository 和 service 四个子目录。 而领域层聚合内部的代码目录结构是这样的。 Aggregate(聚合): 它是聚合软件包的根目录，可以根据实际项目的聚合名称命名，比 如权限聚合。在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。聚合内实现高内聚的业务逻辑，它的代码可以独立拆分为微服务。 以聚合为单位的代码放在一个包里的主要目的是为了业务内聚，而更大的目的是为了以后微 服务之间聚合的重组。聚合之间清晰的代码边界，可以让你轻松地实现以聚合为单位的微服 务重组，在微服务架构演进中有着很重要的作用。 Entity(实体): 它存放聚合根、实体、值对象以及工厂模式(Factory)相关代码。实体 类采用充血模型，同一实体相关的业务逻辑都在实体类代码中实现。跨实体的业务逻辑代码 在领域服务中实现。 Event(事件): 它存放事件实体以及与事件活动相关的业务逻辑代码。 Service(领域服务): 它存放领域服务代码。一个领域服务是多个实体组合出来的一段业 务逻辑。你可以将聚合内所有领域服务都放在一个领域服务类中，你也可以把每一个领域服 务设计为一个类。如果领域服务内的业务逻辑相对复杂，我建议你将一个领域服务设计为一 个领域服务类，避免由于所有领域服务代码都放在一个领域服务类中，而出现代码臃肿的问 题。领域服务封装多个实体或方法后向上层提供应用服务调用。 Repository(仓储): 它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接 口和仓储实现方法。为了方便聚合的拆分和组合，我们设定了一个原则:一个聚合对应一个仓储。 特别说明:按照 DDD 分层架构，仓储实现本应该属于基础层代码，但为了在微服务架构演 进时，保证代码拆分和重组的便利性，我是把聚合仓储实现的代码放到了聚合包内。这样， 如果需求或者设计发生变化导致聚合需要拆分或重组时，我们就可以将包括核心业务逻辑和 仓储代码的聚合包整体迁移，轻松实现微服务架构演进。 4. 基础层 Infrastructure 的代码目录结构有:config 和 util 两个子目录。 Config: 主要存放配置相关代码。 Util: 主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库、 通用算法等基础代码，你可以为不同的资源类别建立不同的子目录。 代码模型总目录结构 在完成一级和二级代码模型设计后，你就可以看到下图这样的微服务代码模型的总目录结构 了。 总结 今天我们根据 DDD 分层架构模型建立了标准的微服务代码模型，在代码模型里面，各代码 对象各据其位、各司其职，共同协作完成微服务的业务逻辑。 第一点:聚合之间的代码边界一定要清晰。 聚合之间的服务调用和数据关联应该是尽可能的 松耦合和低关联，聚合之间的服务调用应该通过上层的应用层组合实现调用，原则上不允许聚合之间直接调用领域服务,可以跨服务调用查询。这种松耦合的代码关联，在以后业务发展和需求变更时，可以 很方便地实现业务功能和聚合代码的重组，在微服务架构演进中将会起到非常重要的作用。 第二点:你一定要有代码分层的概念。 写代码时一定要搞清楚代码的职责，将它放在职责对 应的代码目录内。应用层代码主要完成服务组合和编排，以及聚合之间的协作，它是很薄的 一层，不应该有核心领域逻辑代码。领域层是业务的核心，领域模型的核心逻辑代码一定要 在领域层实现。如果将核心领域逻辑代码放到应用层，你的基于 DDD 分层架构模型的微服 务慢慢就会演变成传统的三层架构模型了。 数据持久化对象 PO(Persistent Object)，与数据库结构一一映射，是数据持久化过程中 的数据载体。 领域对象 DO(Domain Object)，微服务运行时的实体，是核心业务的载体。 数据传输对象 DTO(Data Transfer Object)，用于前端与应用层或者微服务之间的数 据组装和传输，是应用之间数据传输的载体。 视图对象 VO(View Object)，用于封装展示层指定页面或组件的数据。 我们结合下面这张图，看看微服务各层数据对象的职责和转换过程。 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"blogs/DDD/资金认领的实践.html":{"url":"blogs/DDD/资金认领的实践.html","title":"资金认领的实践","keywords":"","body":"领域模型设计(DDD)资金认领的实践 一、项目背景 从CBS获取客户对涂鸦的收款记录，通过银行流水中的涂鸦银行账号、客户付款账号关联资金账户信息、客户信息 通过资金自动认领配置表，对资金账户、客户信息匹配成功的数据进行认领操作 自动推送资金认领数据到SAP生成对应的凭证 1.1需求目标 实现付款流水的自动认领 实现手动上传的流水的手动认领 认领成功自动生成SAP接口 整个项目分为两大业务域，分别是资金行域、配置中心域。其中，资金行域主要负责资金行收集、资金行管理等功能；配置中心域负责管理一些公共配置资源 图1-1 资金认领总览图 二、领域驱动基础概念介绍 在介绍DDD相关基础概念前，我先说明下为什么要使用DDD？在非DDD设计思路下的项目，我们一般先根据需求做数据库表的设计，然后根据表结构设计推导出相应的实体对象，这样的实体对象是数据模型转换的结果。此时，这些对象只是数据的载体，是没有行为的。在这种设计模式下，业务流程实现上仍旧是面向过程式，是一种以数据为中心的过程式思想，其开发过程可以理解为是对数据移动、处理和实现的过程。而如果采用DDD的思想去设计，我们将建立一个基于面向对象设计的系统。接下来，我先介绍DDD的标准分层架构，然后介绍下需求分析阶段非常有用的四色原型分析模式，最后简要介绍下方案设计阶段常用到的几个DDD领域概念。 2.1 领域驱动设计标准分层架构 图2-1 领域驱动架构模型 2.1.1 基础设施层 基础设施层主要为其他层提供通用的技术能力，比如，应用的消息发送、领域持久化等。在实际的项目应用中，本层主要用于持久化数据的读取和写入，我们可以在这一层，将需要持久化的领域对象序列化到指定的存储介质中，比如：数据库、Hbase、MongoDB、ES等，同理，亦可从这些存储介质中取出数据并组装成领域对象。在这一层，一般会采用仓储机制实现领域持久化能力。 2.1.2 领域层 2.1.3 应用层 2.1.4 用户界面层 2.1.5应用工程结构简单介绍 2.2 需求分析利器 — 四色原型图 简单的业务需求，一般使用用例图就可以表述清楚了，如果业务再复杂一些，我们可以附加一些时序图、状态图等加以说明，但是当业务非常复杂时，怎么去寻找业务中的关键点以及各个点之间的联系呢？或者有没有一个比较科学的理论，指引我们去分析呢？我们可以考虑使用四色原型分析模式。它主要用于业务分析阶段，用来分析业务行为、参与对象、业务对象关系等。那什么是四色原型图呢？我们先来看下它的四个构成元素，具体如下： （1）时刻-时间段原型（Moment-Interval Archetype） 生日期、行为人；租房行为是在一段时间内发生的，它有开始、结束时间和退租行为。这些我们都是可以通过此原型来表达的。在画原型图时，采用粉红色表示。 （2）参与方-地点-物品原型（Part-Place-Thing Archetype） 原型简称PPT，用来表示参与某个活动的人或物，地点则是活动的发生地。比如签署租房合同这个行为，合同、承租人分别对应这里的物、人，中介办公室对应这里的地点。在画原型图时，使用绿色表示。 （3）描述原型（Description Archetype） 原型简称DESC，是对PPT公共属性的描述，拿“签署租房合同”这个场景为例，在合同中会有一些租期、租金、押金、违约条件等约定，这些约定信息便可采用DESC原型来描述。绘制原型图时，采用蓝色表示。 （4）角色原型（Role Archetype） 原型简称Role，这里的角色，就是我们平时所理解的“身份”。以“签署租房合同”这个场景为例，签署行为人有承租人和中介工作人员，这里的角色便是指“承租人”和“中介工作人员”。绘制原型图时，采用黄色表示。 总结：如果必须要用一句话来概括四色原型的话，那就是：一个什么样的人或物以某种角色在某个时刻或某段时间内在某个地点参与某个活动。 其中“什么样的”就是DESC，“人或物”、“地点”就是PPT，“角色”就是Role，而”某个时刻或某段时间内的某个活动\"就是MI。 2.3 DDD几个核心领域概念 2.3.1 实体 实体是一个具有身份和连贯性的概念，它具有以下几个特征： - 实体是数据（属性）和行为（业务逻辑关系）的结合体； - 每个实体都有自己的唯一标识，判断两个实体对象是否相等，是通过唯一标识来判断的。比如，两个实体对象，如果唯一标识相等，即使其他属性不相等，这两个实体也会认为是同一个。实体的其他属性不相等，表征的是同一个实体在其生命周期的不同阶段。 - 实体的唯一标识属性值是不可变的，其他属性值是可变的。 举个例子简单说明下，比如在有赞精选内容平台（类似于小红书的电商导购平台）这个业务域中，每一篇“博文”就是一个业务实体，可以采用“博文id”作为实体的唯一标识，然后这个博文实体拥有着属性（标题、作者、发表时间、内容等）和行为（更新博文、删除博文、关联导购商品等），同时，属性是会随着行为而不断变化的。 2.3.2 值对象 值对象一般会作为一个属性存放于一个实体内部，它具有以下几个特征： - 值对象不需要唯一标识，判断两个值对象是否相等，是通过值对象内部所有属性值是否相等来判断的。 - 值对象的属性值是不允许变化的，即值对象的实体在创建之后就不会变了，如果要改变其属性值，就需要先把此对象删除，然后重新创建一个新对象。 同样以“有赞精选内容平台”为例说明下，用户可以针对博文发起留言，同时，我们会精选出一些留言置顶，对于“置顶的留言”我们可以定义为值对象，并将其作为一个属性放置于博文实体中，一旦置顶留言发生变化，我们只需要将新的置顶留言重建为值对象，并赋值给博文实体的这个属性即可。 2.3.3 聚合 聚合是一组具有内聚关系的领域对象（包括实体和值对象）的集合，这里的一组可以是一个或多个实体。每个聚合都会有一个根实体（亦称聚合根），它主要用来和外界交互，即外部对象如果想访问聚合内的实体，必须先访问聚合根，然后聚合根再和内部要访问的实体进行交互。 除了内聚性和一致性，聚合根还有以下特征： 聚合根的实现应该与框架无关：既然DDD讲求业务复杂度和技术复杂度的分离，那么作为业务主要载体的聚合根应该尽量少地引用技术框架级别的设施，最好是POJO。试想一下，如果你的项目哪天需要从Spring迁移到Play，而你可以自信地给老板说，直接将核心Java代码拷贝过去即可，这将是一种多么美妙的体验。又或者说，很多时候技术框架会有“大步”的升级，这种升级会导致框架中API的变化并且不再支持向后兼容，此时如果我们的领域模与框架无关，那么便可做到在框架升级的过程中幸免于难。 聚合根之间的引用通过ID完成：在聚合根边界设计合理的情况下，一次业务用例只会更新一个聚合根，此时你在该聚合根中去引用另外聚合根的整体有什么好处呢？在本文示例中，一个Order下的OrderItem引用了ProductId，而不是整个Product。 聚合根内部的所有变更都必须通过聚合根完成：为了保证聚合根的一致性，同时避免聚合根内部逻辑向外泄露，客户方只能将整个聚合根作为统一调用入口。 如果一个事务需要更新多个聚合根，首先思考一下自己的聚合根边界处理是否出了问题，因为在设计合理的情况下通常不会出现一个事务更新多个聚合根的场景。如果这种情况的确是业务所需，那么考虑引入消息机制和事件驱动架构，保证一个事务只更新一个聚合根，然后通过消息机制异步更新其他聚合根。 聚合根不应该引用基础设施。 外界不应该持有聚合根内部的数据结构。 尽量使用小聚合。 2.3.4 仓储 首先说明下仓储被设计出来的初衷，在领域模型中，对象被创建出来后一般会在内存中活动，待其不活动了后，需要将其进行持久化存储。然后，当我们需要重建对象时，需要根据对象当前状态进行重建。可见这整个过程中，会频繁的与数据库（广义的数据库，包括关系型数据库、NoSql数据库等）打交道，进行对象的创建、组装等。因而，能否提供一种机制，帮助我们管理领域对象以及做对象持久化，仓储并应运而生了。 仓储，又称资源库，它具有以下几个特征： - 仓储是连接领域层和基础设施层的桥梁，一般将仓储接口定义放在领域层，仓储的具体实现放在基础设施层。这样做的好处是：解耦了领域层与ORM之间的联系，任何ORM相关的变更，只需要修改仓储的实现便可，对于领域层仓储接口的定义一般是不需要做修改的。 - 仓储里面存储的对象一定是聚合，因为领域模型中都是以聚合来划分业务边界的，所以在实际应用中，我们只会对聚合设计仓储。同理，我们在仓储中做数据更新、删除等操作时，应该以聚合为单位进行操作，而不是仅操作聚合中的某一个实体。 三、DDD实战 结合四色原型图，设计领域模型的步骤可概括为以下几步： 根据需求，采用四色原型分析法建立一个初步的领域模型； 进一步分析领域模型，识别出哪些是实体，哪些是值对象，哪些是领域服务； 对实体、值对象进行关联和聚合，提炼出聚合边界和聚合根； 为聚合根设计仓储（一般情况下，一个聚合分配一个仓储），同时，思考实体、值对象的创建方式，是通过工厂创建，还是直接通过构造函数； 走查需求场景，验证设计的领域模型的合理性。3.1 场景分析提炼四色原型图 3.2 领域模型中实体/值对象/领域服务/聚合识别 一般来说，可以将四色原型图中的原型和DDD做简单的映射，比如：PPT原型描述的是某个活动下的唯一个体，其可对应到DDD中的实体；Role原型表述的是实体在不同状态下的表现，一般将其放置于实体中，一起构成一个完整的带状态实体；DESC原型描述的是PPT的公共属性，一般作为值对象存储；MI原型描述的是某个活动，可间接对应领域服务。 线索域实体 接着，我们进一步分析实体间的关系，提炼出聚合边界和聚合根，并定义出仓储。 在资金行域中，资金行是核心，很明显capitalEntity与claimEntity、payerEntity、payeeEntity是相关联的，而后三者间是没有联系的。首先，来看下capitalEntity和payerEntity、payeeEntity，资金行在创建之初是需要强制绑定我方账户和对方账户，而我方账户和对方账户脱离资金行是不具有存在价值的。同时，本项目中，我方账户和对方账户仅作为资金行的归属属性存在，最终我们将payerEntity和payeeEntity（改名为payerVO和payeeVO）作为值对象放置于capitalEntity内，且令资金行信息实体为聚合根；然后，分析下capitalEntity与claimEntity、payerEntity、payeeEntity，主要从两个方面考虑是否需要组成聚合： （1）聚合代表的是一个完整的概念，具有内部一致性，即聚合内的对象要么一起获取，要么一起更新，要么一起删除。假如聚合在被保存时，内部任意一个对象被修改了，都需视为聚合被修改了，此时应令保存失败。所以，在定义聚合时，在保证合理性的情况下，尽量设计小的聚合。在资金行中，定时任务会频率修改认领信息，从内部一致性角度考虑，二者分开可能会更好。 （2）聚合内聚合根和对象间要保持不变性。何为不变性？简单来说，对象之间存在某种不变的规则。举个例子说明下，x=y+5，如果规定y大于1，那么x一定大于6。 结合以上两点，这里我采用的策略是：capitalEntity与claimEntity二者各自定义为一个聚合，本身作为聚合根。那问题也来了，在查询资金行详情时，资金行是包含认领信息的，但是capitalEntity聚合内又不包含三者，此时该怎么解决信息聚合呢？我们采用了领域服务，来做领域对象间的聚合。 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"blogs/git/directory.html":{"url":"blogs/git/directory.html","title":"git","keywords":"","body":"目录 git发布流程 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"blogs/git/git发布流程.html":{"url":"blogs/git/git发布流程.html","title":"git发布流程","keywords":"","body":"git发布流程 开发环境 1.1创建feature_v1.0分支 创建分支名:feature_v1.0 命令:git checkout master git checkout -b feature_v1.0 上架:feature_v1.0 需创建git临时分支 更新:feature_v1.0 临时分支合并feature_v1.0 1.2上架 创建临时分支名:dev_temp_0001 命令: git checkout master git checkout -b dev_temp_0001 合并分支:git merge feature_v1.0 删除历史临时分支:git branch -d dev_temp_0000 1.3开发环境更新 合并分支:git checkout dev_temp_0001 git merge feature_v1.0 2.1创建feature_v1.1分支 创建分支名:feature_v1.1 命令:git checkout master git checkout -b feature_v1.1 上架:feature_v1.0 需创建git临时分支 更新:feature_v1.0 临时分支合并feature_v1.0 2.2上架 方案1:创建临时分支名:dev_temp_0002 命令: git checkout master git checkout -b dev_temp_0002 合并分支:git merge feature_v1.0 git merge feature_v1.1 合并顺序 按上架顺序来合并 先合并v1.0 再合并v1.1 方案2:创建临时分支名:dev_temp_0002 命令: git branch dev_temp_0001 git checkout -b dev_temp_0002 以上一个临时分支(dev_temp_0001)为基准，拉取新的临时分支 合并分支:git merge feature_v1.1 合并顺序 按上架顺序来合并 先合并v1.0 再合并v1.1 合并之前准备工作: git log 获取版本号【57955c461ca41dff144e2d1a1a6193e4377ce393】 合并无冲突:删除历史临时版本 合并出现冲突:在合并v1.1冲突时，获取合并冲突记录git diff 显示记录冲突内容 撤销merge操作:git reset --head 【merge前的版本号】 解决合并冲突:将源分支代码合并到目标分支，在目标分支上解决冲突后提交push, 在gitlab上点合并冲突的Merge Rquests，再在penglai上点击重试。 是重试，不是重新部署。 git merge feature_v1.1 或 git pull feature_v1.1 手动处理冲突后 git add '冲突文件' 然后git commit '解决冲突' 删除历史临时分支:git branch -d dev_temp_0001 预发环境 上架 与开发环境上架流程一致 临时分支名pre_temp_XXXX 更新 与开发环境更新流程一致 临时分支名pre_temp_XXXX 生产环境 发布 以预发分支为基准，拉取创建分支Vxxxxx_release分支，然后以该版本为准，编译构建、 系统部署 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"blogs/spring/directory.html":{"url":"blogs/spring/directory.html","title":"spring","keywords":"","body":"目录 @Resource和@Autowired的区别 @Resource、@Autowired、@Value的循环依赖 Spring源码之@Component注解解析 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"blogs/spring/@Resource和@Autowired的区别.html":{"url":"blogs/spring/@Resource和@Autowired的区别.html","title":"@Resource和@Autowired的区别","keywords":"","body":"@Resource和@Autowired的区别 @Resource和@Autowired两个注解大家应该很熟悉，在spring中我们通常使用@Resource和@Autowired做bean的注入时使用。有的时候它们是等价的，使用哪个都可以。但有的时候则不可以。接下来我们看看他们的区别吧。 相同点： spring中都可以用来注入bean，同时都还可以作为注入属性的修饰。在接口仅有单一实现类时，两个注解的修饰效果是相同的，他们之间可以相互替换，不影响使用。 不同点： @Resource是Java自己的注解，@Resource有两个主要的属性，分别是name和type；spring对@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略。而使用type属性，则是使用byType的自动注入策略。如果既不指定name属性也不指定type属性，这时将通过反射机制使用byName的自动注入策略。 @Autowired是spring的注解，是spring2.5版本引入的，@Autowired注解只根据type进行注入，不会去匹配name。如果涉及到根据type无法辨别的注入对象，将需要依赖@Qualifier或@Primary注解一起来修饰。 @Resource在Spring填充时机是交由org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#postProcessPropertyValues方法 @Autowired在Spring填充时机是交由org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues方法 上面相同点里面说到，如果接口仅有单一实现类的时候，二者的修饰效果是相同的。那如果接口有两个或者两个以上的实现类呢？？？接下来我们就来测试一下 //首先写一个接口 public interface Human { /** * 跑马拉松 * @return */ String runMarathon(); } //接口的第一个实现类 @Service public class Man implements Human { public String runMarathon() { return \"A man run marathon\"; } } //接口的调用 @RestController @RequestMapping(\"/an\") public class HumanController { @Resource private Human human; @RequestMapping(\"/run\") public String runMarathon() { return human.runMarathon(); } } 上面的代码使用的是@Resource注解，代码可以正常运行。如果换成@Autowired注解，效果也是一样的，可以正常运行 接下来，我们在上面代码的基础上在给接口添加一个实现类 //接口的第二个实现类 @Service public class Woman implements Human { public String runMarathon() { return \"An woman run marathon\"; } } 1、控制类里面如果使用@Resource注解，启动的时候会报错，核心的错误信息如下： org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'humanController': Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.example.demo1.Human' available: expected single matching bean but found 2: man,woman 这是我们就要借助@Resource注解的name属性或者@Qualifier来确定一个合格的实现类 只需要将控制类里面的注解改为如下即可： @Resource(name=\"woman\") private Human human; //或者 @Resource @Qualifier(\"woman\") private Human human; 2、控制类里面如果使用@Autowired注解，启动的时候会报错，错误信息如下： Description: Field human in com.example.demo1.HumanController required a single bean, but 2 were found: - man: defined in file [/Users/yangdeke/IdeaProjects/test/demo1/target/classes/com/example/demo1/Man.class] - woman: defined in file [/Users/yangdeke/IdeaProjects/test/demo1/target/classes/com/example/demo1/Woman.class] Action: Consider marking one of the beans as @Primary, updating the consumer to accept multiple beans, or using @Qualifier to identify the bean that should be consumed 报错信息很明显，HumanController需要一个bean实现，但是找到了两个 man 和woman 解决方案：使用@Primary注解，在有多个实现bean时告诉spring首先@Primary修饰的那个；或者使用@Qualifier来标注需要注入的类。 @Qualifier修改方式与改动二的相同，依然是修改HumanController.java 中间注入的Human上面，这里不再复述 @Primary是修饰实现类的，告诉spring，如果有多个实现类时，优先注入被@Primary注解修饰的那个。这里，我们希望注入Man.java ，那么修改Man.java为如下情况 @Service @Primary public class Man implements Human { public String runMarathon() { return \"A man run marathon\"; } } 通过上面的案例我们就可以很明显的看出来他们之间的区别了。同时遇到问题也知道该如何解决了。 推荐使用：@Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。这样代码看起就比较优雅 最后呢，说一下个人的见解，平时的开发过程中呢，更常用的是@Autowired注解，因为平时百分之九十以上都是一个接口仅有一个实现类，所以用@Autowired比较方便，当然这种情况用两个中的哪一个都一样，没什么太大的区别，纯属个人习惯。但是如果是生产环境的话，架构师对这方面要求有比较严格的情况下，会让大家使用@Resource(name=\"xxx\")这种，因为在生产环境就会要求更高的效率问题，这样使用效率是最高的，类似于根据id查询数据库一样，效率高一些。所以根据个人情况，选择性使用吧。。。 链接：https://www.jianshu.com/p/e4a899bfd18b By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"blogs/spring/@Resource、@Autowired、@Value的循环依赖.html":{"url":"blogs/spring/@Resource、@Autowired、@Value的循环依赖.html","title":"@Resource、@Autowired、@Value的循环依赖","keywords":"","body":"@Resource、@Autowired、@Value的循环依赖问题 @Resource和@Autowired两个注解大家应该很熟悉，在spring中我们通常使用@Resource和@Autowired做bean的注入时使用。Spring 创建 bean 的流程，即 Spring 先通过反射创建一个原始的 bean 对象，然后再向这个原始的 bean 对象中填充属性。 在Bean实例化时候属性填充方法入口:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean,方法中会将业务逻辑交由不同的spring后置处理器 InstantiationAwareBeanPostProcessor==>BeanPostProcessor。 填充时机： @Resource在Spring填充时机是交由org.springframework.context.annotation.CommonAnnotationBeanPostProcessor#postProcessPropertyValues方法 @Autowired在Spring填充时机是交由org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues方法 从图中可知:后置处理器按排序依次执行 CommonAnnotationBeanPostProcessor 早于 AutowiredAnnotationBeanPostProcessor 正常bean填充参数： @Component public class BeanConfig { @Value(\"${id}\") private String id; @Value(\"${name}\") private String name; // @Resource // private Example1 example1; @Bean public Example example(){ Example example = new Example(); example.setId(id); example.setName(name); return example; } } public class Example { private String id; private String name; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Example{\" + \"id='\" + id + '\\'' + \", name='\" + name + '\\'' + '}'; } } @RestController @RequestMapping public class ExampleController { @Autowired private Example example; @RequestMapping(\"/example\") public String example() { return example.toString(); } } 输出结果: Example{id='ide', name='name'} 依赖bean填充参数 @Component public class BeanConfig { @Value(\"${id}\") private String id; @Value(\"${name}\") private String name; @Resource private Example1 example1; @Bean public Example example(){ Example example = new Example(); example.setId(id); example.setName(name); return example; } } @Component public class Example1 { @Autowired private Example example; } 输出结果: Example{id='null', name='null'} 如果将 @Resource 将修改成 @Autowired @Component public class BeanConfig { @Value(\"${id}\") private String id; @Value(\"${name}\") private String name; @Autowired private Example1 example1; @Bean public Example example(){ Example example = new Example(); example.setId(id); example.setName(name); return example; } } @Component public class Example1 { @Autowired private Example example; } 输出结果又正常了 Example{id='ide', name='name'} 如果将 @Autowired 和 @Value 位置对换一下 @Component public class BeanConfig { @Autowired private Example1 example1; @Value(\"${id}\") private String id; @Value(\"${name}\") private String name; @Bean public Example example(){ Example example = new Example(); example.setId(id); example.setName(name); return example; } } @Component public class Example1 { @Autowired private Example example; } BeanConfig类什么时候处理@Bean/@Value/@Resource/@Autowired注解 AnnotationConfigUtils.registerAnnotationConfigProcessors方法的调用中， 可以看到spring注册了多个与注解处理相关的类，其中包括用于处理@Configuration或@ComponentScan注解配置的类ConfigurationClassPostProcessor @Bean:相当于定义BeanDefinition 放到BeanDefinitionMap中去，方法名为beanName。待更新 @Value:扫描@Component注解类，将类信息存放到放到BeanDefinitionMap中去，然后交由spring容器准备实例化bean 触发属性填充。填充逻辑将在AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues方法 @Resource:扫描@Component注解类，将类信息存放到放到BeanDefinitionMap中去，然后交由spring容器准备实例化bean 触发属性填充。填充逻辑将在CommonAnnotationBeanPostProcessor#postProcessPropertyValues方法 @Autowired:扫描@Component注解类，将类信息存放到放到BeanDefinitionMap中去，然后交由spring容器准备实例化bean 触发属性填充。填充逻辑将在AutowiredAnnotationBeanPostProcessor#postProcessPropertyValues方法 所以@Bean类中的初始化流程慢于@Value属性填充。 正常情况: 这种情况很常用，比如平时使用config类 注入一些外部配置类如:kafka、redis、dubbo、邮箱信息。 @Resource异常情况: 当类之间存在依赖关系时，就会可能存在异常。这一种情况比较隐秘，可能存在多级依赖，不容易发现。一般情况配置mq config信息会出现。 这是因为CommonAnnotationBeanPostProcessor 早于 AutowiredAnnotationBeanPostProcessor Example会先初始化后再执行@Value填充参数逻辑，导致Example参数为空。 @Autowired正常情况: @Autowired异常情况: @Value和@Autowired 都将在填充逻辑将在AutowiredAnnotationBeanPostProcessor后置处理器处理逻辑, AutowiredFieldElement.inject()方法 AutowiredFieldElement生成逻辑在AutowiredAnnotationBeanPostProcessor#findAutowiringMetadata中执行AutowiredAnnotationBeanPostProcessor#buildAutowiringMetadata 然后根据代码位置依次排序生成AutowiredFieldElement。 代码如下: public class AutowiredAnnotationBeanPostProcessor extends InstantiationAwareBeanPostProcessorAdapter implements MergedBeanDefinitionPostProcessor, PriorityOrdered, BeanFactoryAware { private InjectionMetadata buildAutowiringMetadata(final Class clazz) { LinkedList elements = new LinkedList(); Class targetClass = clazz; do { final LinkedList currElements = new LinkedList(); //获取字段上的注解 ReflectionUtils.doWithLocalFields(targetClass, new ReflectionUtils.FieldCallback() { @Override public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException { //循环依次获取注解信息 AnnotationAttributes ann = findAutowiredAnnotation(field); if (ann != null) { if (Modifier.isStatic(field.getModifiers())) { if (logger.isWarnEnabled()) { logger.warn(\"Autowired annotation is not supported on static fields: \" + field); } return; } boolean required = determineRequiredStatus(ann); currElements.add(new AutowiredFieldElement(field, required)); } } }); //获取方法上的注解 ReflectionUtils.doWithLocalMethods(targetClass, new ReflectionUtils.MethodCallback() { @Override public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException { Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) { return; } AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod); if (ann != null && method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) { if (Modifier.isStatic(method.getModifiers())) { if (logger.isWarnEnabled()) { logger.warn(\"Autowired annotation is not supported on static methods: \" + method); } return; } if (method.getParameterTypes().length == 0) { if (logger.isWarnEnabled()) { logger.warn(\"Autowired annotation should only be used on methods with parameters: \" + method); } } boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); currElements.add(new AutowiredMethodElement(method, required, pd)); } } }); elements.addAll(0, currElements); targetClass = targetClass.getSuperclass(); } while (targetClass != null && targetClass != Object.class); return new InjectionMetadata(clazz, elements); } private AnnotationAttributes findAutowiredAnnotation(AccessibleObject ao) { if (ao.getAnnotations().length > 0) { for (Class type : this.autowiredAnnotationTypes) { AnnotationAttributes attributes = AnnotatedElementUtils.getMergedAnnotationAttributes(ao, type); if (attributes != null) { return attributes; } } } return null; } } 结论 说一下个人的见解: 如果可以，尽量使用@Autowired注解把,如果是生产环境的话，架构师对这方面要求有比较严格的情况下，会让大家使用@Resource(name=\"xxx\")这种，因为在生产环境就会要求更高的效率问题，这样使用效率是最高的，类似于根据id查询数据库一样，效率高一些。不过这一点效率不关紧要。 bean依赖关系，尽量成树形结构，避免网状生成循环依赖。 bean依赖层级尽量不要超过四层，一旦链路过长，属性填充导入时，风险和bug也将逐步提升，且出现异常不好排查原因。 先写@Autowired 再写@Value By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"blogs/spring/Spring源码之@Component注解解析.html":{"url":"blogs/spring/Spring源码之@Component注解解析.html","title":"Spring源码之@Component注解解析","keywords":"","body":"Spring源码之@Component注解解析 使用 @Component的作用就是将类注入到spring容器中 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Indexed public @interface Component { /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) */ String value() default \"\"; } 源码分析 在 ConfigurationClassParser#doProcessConfigurationClass 方法中 //判断类上面是否有Component注解 if (configClass.getMetadata().isAnnotated(Component.class.getName())) { // Recursively process any member (nested) classes first //递归处理有@Component注解的内部类 processMemberClasses(configClass, sourceClass, filter); } configClass.getMetadata()可以拿到类的元数据信息 如果类上面有@Component注解，则进行解析操作processMemberClasses public class ConfigurationClassParser{ private void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass, Predicate filter) throws IOException { //获取该类的内部类并又包装成sourceClass对象 Collection memberClasses = sourceClass.getMemberClasses(); if (!memberClasses.isEmpty()) { List candidates = new ArrayList<>(memberClasses.size()); for (SourceClass memberClass : memberClasses) { //如果类是候选的 if (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) && !memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) { candidates.add(memberClass); } } //排序 OrderComparator.sort(candidates); //循环去处理每一个内部类 for (SourceClass candidate : candidates) { if (this.importStack.contains(configClass)) { this.problemReporter.error(new CircularImportProblem(configClass, this.importStack)); } else { this.importStack.push(configClass); try { //candidate 子 configClass 父，candidate 是 configClass的内部类 processConfigurationClass(candidate.asConfigClass(configClass), filter); } finally { this.importStack.pop(); } } } } } } 如果类中有内部类，那么要先拿到内部类，因为内部类上面也有可能有注解 ````java public class ConfigurationClassParser{ public Collection getMemberClasses() throws IOException { Object sourceToProcess = this.source; if (sourceToProcess instanceof Class) { Class sourceClass = (Class) sourceToProcess; try { //获取内部类 Class[] declaredClasses = sourceClass.getDeclaredClasses(); List members = new ArrayList<>(declaredClasses.length); for (Class declaredClass : declaredClasses) { members.add(asSourceClass(declaredClass, DEFAULT_EXCLUSION_FILTER)); } return members; } catch (NoClassDefFoundError err) { // getDeclaredClasses() failed because of non-resolvable dependencies // -> fall back to ASM below sourceToProcess = metadataReaderFactory.getMetadataReader(sourceClass.getName()); } } } } 链接：https://blog.csdn.net/qq_27023083/article/details/113245337 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"question/directory.html":{"url":"question/directory.html","title":"问题","keywords":"","body":"问题 springboot 数据源配置问题 java snowflake时间回退问题 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"question/springboot/directory.html":{"url":"question/springboot/directory.html","title":"springboot","keywords":"","body":"目录 数据源配置问题 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"question/springboot/数据源配置问题.html":{"url":"question/springboot/数据源配置问题.html","title":"数据源配置问题","keywords":"","body":"springboot java.sql.SQLException: Access denied for user ''@'localhost' (using password: NO) 报异常： java.sql.SQLException: Access denied for user ''@'localhost' (using password: YES) 报错原因分析:''@'localhost'引号中用户名为空 说明没将用户名传到数据源中 spring boot 原配置 spring.datasource.url = jdbc:mysql://localhost:3306/ddd spring.datasource.name = root spring.datasource.password = root spring.datasource.driver-class-name=com.mysql.jdbc.Driver 修改后 spring.datasource.url = jdbc:mysql://localhost:3306/ddd spring.datasource.username = root spring.datasource.password = root spring.datasource.driver-class-name=com.mysql.jdbc.Driver By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"question/java/directory.html":{"url":"question/java/directory.html","title":"java","keywords":"","body":"JAVA snowflake时间回退问题 By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "},"question/java/snowflake时间回退.html":{"url":"question/java/snowflake时间回退.html","title":"snowflake时间回退问题","keywords":"","body":"snowflake时间回退 时间校准，以及其他因素，可能导致服务器时间回退（时间向前快进不会有问题），如果恰巧回退前生成过一些ID，而时间回退后，生成的ID就有可能重复。官方对于此并没有给出解决方案，而是简单的抛错处理，这样会造成在时间被追回之前的这段时间服务不可用。 //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp 修改后 //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常 if (timestamp By diyiyao，使用知识共享 署名-相同方式共享 4.0协议发布            此页面修订于： 2021-04-13 03:40:54 "}}